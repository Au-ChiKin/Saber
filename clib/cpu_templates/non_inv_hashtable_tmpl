enum AggregationType {MIN, MAX};


template <class Value, AggregationType type>
class TwoStacks {
public:
    Value currValue;
private:
    int size;
    Value *queue;
    int queueFront;
    int queueRear;
    int backStackSize;
    int backStackPointer;
    Value backStackValue;
    int frontStackSize;
    int frontStackPointer;
    Value *frontStackValues;
public:
    TwoStacks () : TwoStacks(BUCKET_SIZE) {}
    TwoStacks (int size) {
        // rounding up to next power of 2
        size = round(size);
        this->size = size;
        this->queue = (Value *)  malloc( sizeof(Value) * size );
        this->queueFront = -1;
        this->queueRear = -1;
        this->backStackSize = 0;
        this->backStackPointer = -1;
        this->backStackValue = (type == MIN) ? (Value) FLT_MAX : (Value) FLT_MIN;
        this->frontStackSize = 0;
        this->frontStackPointer = -1;
        this->frontStackValues = (Value *)  malloc( sizeof(Value) * size );
    }

    void insert (Value inputValue) {
        Value tempValue =(this->backStackSize==0) ? ((type == MIN) ? (Value) FLT_MAX : (Value) FLT_MIN) :
                this->backStackValue;
        if (type == MIN) {
            this->backStackValue = (tempValue < inputValue) ? this->backStackValue : inputValue;
        } else {
            this->backStackValue = (tempValue > inputValue) ? this->backStackValue : inputValue;
        }
        this->backStackSize++;
        this->backStackPointer++;
        if (this->backStackPointer == this->size)
            this->backStackPointer = 0;
        enqueue(inputValue);
    }

    void evict () {
        if (this->frontStackSize == 0) // swap if the front stack is empty and we can't evict
            swap ();
        this->frontStackSize--;
        this->frontStackPointer++;
        if (this->frontStackPointer == this->size)
            this->frontStackPointer = 0;
        dequeue();
    }

    Value query () {
        Value tempValue1, tempValue2;
        switch(type) {
            case MIN:
                tempValue1 = (this->frontStackSize == 0) ? (Value) FLT_MAX : this->frontStackValues[this->frontStackSize-1];
                tempValue2 = (this->backStackSize == 0) ? (Value) FLT_MAX : this->backStackValue;
                this->currValue = (tempValue1 < tempValue2) ? tempValue1 : tempValue2;
                break;
            case MAX:
                tempValue1 = (this->frontStackSize == 0) ? (Value) FLT_MIN : this->frontStackValues[this->frontStackSize-1];
                tempValue2 = (this->backStackSize == 0) ? (Value) FLT_MIN : this->backStackValue;
                this->currValue = (tempValue1 > tempValue2) ? tempValue1 : tempValue2;
        }
        return this->currValue;;
    }

    Value getCurrentValue () {
        return this->currValue;
    }

    /*void printQueue () {
        printf("[ ");
        if (this->queueFront < this->queueRear) {
            for (int i = this->queueFront; i < this->queueRear; i++) {
                printf("%ld, ", this->queue[i]);
            }
        } else {
            for (int i = this->queueFront; i < this->size; i++) {
                printf("%ld, ", this->queue[i]);
            }
            for (int i = 0; i < this->queueRear; i++) {
                printf("%ld, ", this->queue[i]);
            }
        }
        printf("] \n");
    }*/

    void deleteTwoStacks () {
        free(this->queue);
        free(this->frontStackValues);
    }

private:
    inline int round (int value) {
        if (!(value && (!(value&(value-1))))) {
            value--;
            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            value++;
        }
        return value;
    }

    inline void enqueue (Value inputValue) {
        if ((this->queueFront == 0 && this->queueRear == this->size-1)){ //|| (tRear == tFront-1)) {
            printf("Queue is Full \n");
            throw;
        } else {
            if (this->queueFront == -1) { /* Insert First Element */
                this->queueFront = 0;
            }
            this->queueRear++;
            if (this->queueRear == this->size)
                this->queueRear = 0;
            queue[this->queueRear] = inputValue;
        }
    }

    inline void dequeue () {
        if (this->queueFront == -1) {
            printf("Queue is Empty \n");
        }
        if (this->queueFront == this->queueRear) {
            this->queueFront = -1;
            this->queueRear = -1;
        }
        else {
            this->queueFront = (this->queueFront + 1);
            if (this->queueFront == this->size)
                this->queueFront = 0;
        }
    }

    inline void swap () {
        Value tempValue = (type == MIN) ? (Value) FLT_MAX : (Value) FLT_MIN;
        int outputIndex;
        int inputIndex = this->backStackPointer;
        int limit = this->backStackSize;
        Value *arr = this->queue;
        Value *outputStackArr = this->frontStackValues;
        for (outputIndex=0 ; outputIndex<limit; outputIndex++) {
            if (type == MIN) {
                tempValue = (tempValue < arr[inputIndex]) ? tempValue : arr[inputIndex];
            } else {
                tempValue = (tempValue > arr[inputIndex]) ? tempValue : arr[inputIndex];
            }
            outputStackArr[outputIndex] = tempValue;
            inputIndex--;
        }
        this->backStackSize = 0;
        this->backStackPointer = -1;
        this->frontStackSize = limit;
        this->frontStackPointer = this->queueRear - this->frontStackSize + 1;
        //if (this->frontStackPointer < 0)
        //    this->frontStackPointer = (this->queueRear + this->frontStackSize) & (this->size -1);
    }
};



template <class Key, class Value>
struct ht_node {
    char status;
    long timestamp;
    Key key;
    Value value;
    Value sum;
    int counter;
    //char padding[3];
};


template <class Key, class Value, AggregationType type>
class hashtable {
private:
    int size;
    struct ht_node<Key, Value> *table;
    TwoStacks<Value, type> *twoStacksArray;

private:

    inline int round (int value) {
        if (!(value && (!(value&(value-1))))) {
            value--;
            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            value++;
        }
        return value;
    }

    inline int hashFunction (const int x) { return (x & (this->size - 1)); }
    inline int hash (const int *key) {
        return hashFunction(*key);
    }
    inline int hash (const long *key) {
        return hashFunction((int) *key);
    }
    inline int hash (const float *key) {
        return hashFunction((int) *key);
    }
    inline int hash (const void *key) {
        /*unsigned */int hashval = 0;
        int i = KEY_SIZE-1;

        unsigned char * diref = (unsigned char *) key;
        /* Convert key to an integer */
        while (i >= 0) { // little-endian
            hashval = hashval << 8;
            hashval += diref[i];
            i--;
        }
        //printf ("%d \n", hashval);
        return hashFunction(hashval);
    }

    inline bool isEqual (const int *v1, const int *v2) { return *v1 == *v2; }
    inline bool isEqual (const long *v1, const long *v2) { return *v1 == *v2; }
    inline bool isEqual (const float *v1, const float *v2) { return *v1 == *v2; }
    inline bool isEqual (const void *v1, const void *v2) { return memcmp(v1, v2, KEY_SIZE) == 0; }

public:

    hashtable () : hashtable(MAP_SIZE) {}
    hashtable (int size) {
        // rounding up to next power of 2
        size = round(size);
        this->size = size;
        this->table = (ht_node<Key, Value> *)  malloc( sizeof(ht_node<Key, Value>) * size );

        this->twoStacksArray = (TwoStacks<Value, type> *)  malloc( sizeof(TwoStacks<Value, type>) * BUCKET_SIZE * size );
        //printf("%d \n", sizeof(ht_node<Key, Value>));
        for (int i = 0; i < size; i++) {
            memset(&this->table[i], 0, sizeof(ht_node<Key, Value>));
            this->twoStacksArray[i] = TwoStacks<Value, type>();
        }
    }

    hashtable (ht_node<Key, Value> * table) : hashtable(table, MAP_SIZE) {}

    hashtable (ht_node<Key, Value> * table, int size) {
        this->table = table;
        this->size = size;
    }

    int getSize () { return this->size; }

    ht_node<Key, Value> * getTable () { return this->table; }

    void insert (const Key * key, const Value value, const long timestamp) {
        int ind = hash(key), i = ind;
        char tempStatus;
        for (; i < this->size; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) { //update
                this->twoStacksArray[i].insert(value);
                return;
            }
            if (!tempStatus) { // first insert
                this->table[i].status = 1;
                this->table[i].timestamp = timestamp;
                memcpy(&this->table[i].key, key, KEY_SIZE); //strcpy(table[hashIndex].key, key);
                this->twoStacksArray[i].insert(value);
                return;
            }
        }
        for (i = 0; i < ind; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) {
                this->twoStacksArray[i].insert(value);
                return;
            }
            if (!tempStatus) {
                this->table[i].status = 1;
                this->table[i].timestamp = timestamp;
                memcpy(&this->table[i].key, key, KEY_SIZE); //strcpy(table[hashIndex].key, key);
                this->twoStacksArray[i].insert(value);
                return;
            }
        }

        printf ("error: the hashtable is full \n");
        exit(1);
    }

    void evict (const Key * key) {
        int ind = hash(key), i = ind;
        char tempStatus;
        for (; i < this->size; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) { //update
                this->twoStacksArray[i].evict();
                return;
            }
        }
        for (i = 0; i < ind; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) {
                this->twoStacksArray[i].evict();
                return;
            }
        }

        printf ("error: entry not found \n");
        exit(1);
    }

    int insert_and_modify (const Key * key, const Value value, const long timestamp) {
        int ind = hash(key), i = ind;
        char tempStatus;
        for (; i < this->size; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) { //update
                this->table[i].sum += value;
                this->table[i].counter++;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
            if (!tempStatus) { // first insert
                this->table[i].status = 1;
                this->table[i].timestamp = timestamp;
                memcpy(&this->table[i].key, key, KEY_SIZE); //strcpy(table[hashIndex].key, key);
                this->table[i].sum = value;
                this->table[i].counter = 1;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
        }
        for (i = 0; i < ind; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) {
                this->table[i].sum += value;
                this->table[i].counter++;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
            if (!tempStatus) {
                this->table[i].status = 1;
                this->table[i].timestamp = timestamp;
                memcpy(&this->table[i].key, key, KEY_SIZE); //strcpy(table[hashIndex].key, key);
                this->table[i].sum = value;
                this->table[i].counter++;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
        }

        printf ("error: the hashtable is full \n");
        exit(1);
    }

    int evict_and_modify (const Key * key, const Value value, const long timestamp) {
        int ind = hash(key), i = ind;
        char tempStatus;
        for (; i < this->size; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) { //update
                this->table[i].sum -= value;
                this->table[i].counter--;
                this->twoStacksArray[i].evict();
                return 0;
            }
        }
        for (i = 0; i < ind; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) {
                this->table[i].sum -= value;
                this->table[i].counter--;
                this->twoStacksArray[i].evict();
                return 0;
            }
        }

        printf ("error: entry not found \n");
        exit(1);
    }

    int insert_and_increment_counter (const Key * key, const Value value, const long timestamp) {
        int ind = hash(key), i = ind;
        char tempStatus;
        for (; i < this->size; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) { //update
                this->table[i].counter++;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
            if (!tempStatus) { // first insert
                this->table[i].status = 1;
                this->table[i].timestamp = timestamp;
                memcpy(&this->table[i].key, key, KEY_SIZE); //strcpy(table[hashIndex].key, key);
                this->table[i].counter = 1;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
        }
        for (i = 0; i < ind; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) {
                this->table[i].counter++;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
            if (!tempStatus) {
                this->table[i].status = 1;
                this->table[i].timestamp = timestamp;
                memcpy(&this->table[i].key, key, KEY_SIZE); //strcpy(table[hashIndex].key, key);
                this->table[i].counter++;
                this->twoStacksArray[i].insert(value);
                return 0;
            }
        }

        printf ("error: the hashtable is full \n");
        exit(1);
    }

    int evict_and_decrement_counter (const Key * key) {
        int ind = hash(key), i = ind;
        char tempStatus;
        for (; i < this->size; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) { //update
                this->table[i].counter--;
                this->twoStacksArray[i].evict();
                return 0;
            }
        }
        for (i = 0; i < ind; i++) {
            tempStatus = this->table[i].status;
            if (tempStatus && isEqual(&this->table[i].key, key)) {
                this->table[i].counter--;
                this->twoStacksArray[i].evict();
                return 0;
            }
        }

        printf ("error: entry not found \n");
        exit(1);
    }

    void setValues () {
        int size = this->size;
        ht_node<Key, Value> *table = this->table;
        TwoStacks<Value, type> *twoStacks = this->twoStacksArray;
        for (int i = 0; i < size; i++) {
            if (table[i].status) {
                table[i].value = twoStacks[i].query();
            }
        }
    }

    bool get_value (const Key * key, Value &result) {
        int ind = hash(this->size, key), i = ind;
        for (; i < this->size; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                this->table[i].value = this->twoStacksArray[i].query();
                result = this->table[i].value;
                return true;
            }
        }
        for (i = 0; i < ind; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                this->table[i].value = this->twoStacksArray[i].query();
                result = this->table[i].value;
                return true;
            }
        }
        return false;
    }

    bool get_sum (const Key * key, Value &result) {
        int ind = hash(this->size, key), i = ind;
        for (; i < this->size; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                result = this->table[i].sum;
                return true;
            }
        }
        for (i = 0; i < ind; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                result = this->table[i].sum;
                return true;
            }
        }
        return false;
    }

    bool get_counter (const Key * key, int &result) {
        int ind = hash(this->size, key), i = ind;
        for (; i < this->size; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                result = this->table[i].counter;
                return true;
            }
        }
        for (i = 0; i < ind; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                result = this->table[i].counter;
                return true;
            }
        }
        return false;
    }

    bool get_index (const Key * key, int &index) {
        int ind = hash(this->size, key), i = ind;
        for (; i < this->size; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                index = i;
                return true;
            }
            if (!this->table[i].status) {
                index = i;
                return false;
            }
        }
        for (i = 0; i < ind; i++) {
            if ((this->table[i].status) && isEqual(&this->table[i].key, key)) {
                index = i;
                return true;
            }
            if (!this->table[i].status) {
                index = i;
                return false;
            }
        }
        index = -1;
        return false;
    }

    bool get_index (ht_node<Key,Value> * table, const Key * key, int &index) {
        int ind = hash(key), i = ind;
        for (; i < this->size; i++) {
            if ((table[i].status) && isEqual(&table[i].key, key)) {
                index = i;
                return true;
            }
            if (!table[i].status) {
                index = i;
                return false;
            }
        }
        for (i = 0; i < ind; i++) {
            if ((table[i].status) && isEqual(&table[i].key, key)) {
                index = i;
                return true;
            }
            if (!table[i].status) {
                index = i;
                return false;
            }
        }
        index = -1;
        return false;
    }

    void printHashtable () {
        printf("---HashTalbe----\n");
        for (int i = 0; i < this->size; i++) {
            if (this->table[i].status) {
                printf("%d, %f \n", i, this->table[i].value);
            }
        }
    }

    void deleteHashtable () {
        free(this->table);
        for (int i = 0; i < this->size; i++)
            this->twoStacksArray[i].deleteTwoStacks();
    }

    /*~hashtable () {
        free(this->table);
    }*/
};